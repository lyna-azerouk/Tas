# dune exec Miniml
# OCAMLPARAM: unset
# Shared cache: disabled
# Workspace root: /Users/linaazerouk/Documents/M2/Tas/Lambda_dune/Miniml
# Auto-detected concurrency: 8
$ /opt/homebrew/bin/ocamlc.opt -config > /var/folders/yw/d8j7d04955qb2skz9_nc9dqw0000gn/T/dune_f9c439_output
# Dune context:
#  { name = "default"
#  ; kind = "default"
#  ; profile = Dev
#  ; merlin = true
#  ; for_host = None
#  ; fdo_target_exe = None
#  ; build_dir = In_build_dir "default"
#  ; ocaml_bin = External "/opt/homebrew/bin"
#  ; ocaml = Ok External "/opt/homebrew/bin/ocaml"
#  ; ocamlc = External "/opt/homebrew/bin/ocamlc.opt"
#  ; ocamlopt = Ok External "/opt/homebrew/bin/ocamlopt.opt"
#  ; ocamldep = Ok External "/opt/homebrew/bin/ocamldep.opt"
#  ; ocamlmklib = Ok External "/opt/homebrew/bin/ocamlmklib.opt"
#  ; installed_env =
#      map
#        { "INSIDE_DUNE" :
#            "/Users/linaazerouk/Documents/M2/Tas/Lambda_dune/Miniml/_build/default"
#        ; "OCAML_COLOR" : "always"
#        ; "OPAMCOLOR" : "always"
#        }
#  ; findlib_paths = [ External "/Users/linaazerouk/.opam/mini_ml/lib" ]
#  ; ocaml_config =
#      { version = "4.14.0"
#      ; standard_library_default = "/opt/homebrew/lib/ocaml"
#      ; standard_library = "/opt/homebrew/lib/ocaml"
#      ; standard_runtime = "the_standard_runtime_variable_was_deleted"
#      ; ccomp_type = "cc"
#      ; c_compiler = "clang"
#      ; ocamlc_cflags =
#          [ "-O2"; "-fno-strict-aliasing"; "-fwrapv"; "-pthread" ]
#      ; ocamlc_cppflags = [ "-D_FILE_OFFSET_BITS=64" ]
#      ; ocamlopt_cflags =
#          [ "-O2"; "-fno-strict-aliasing"; "-fwrapv"; "-pthread" ]
#      ; ocamlopt_cppflags = [ "-D_FILE_OFFSET_BITS=64" ]
#      ; bytecomp_c_compiler =
#          [ "clang"
#          ; "-O2"
#          ; "-fno-strict-aliasing"
#          ; "-fwrapv"
#          ; "-pthread"
#          ; "-D_FILE_OFFSET_BITS=64"
#          ]
#      ; bytecomp_c_libraries = [ "-lm"; "-lpthread" ]
#      ; native_c_compiler =
#          [ "clang"
#          ; "-O2"
#          ; "-fno-strict-aliasing"
#          ; "-fwrapv"
#          ; "-pthread"
#          ; "-D_FILE_OFFSET_BITS=64"
#          ]
#      ; native_c_libraries = [ "-lm" ]
#      ; native_pack_linker = [ "ld"; "-r"; "-o" ]
#      ; cc_profile = []
#      ; architecture = "arm64"
#      ; model = "default"
#      ; int_size = 63
#      ; word_size = 64
#      ; system = "macosx"
#      ; asm = [ "clang"; "-c"; "-Wno-trigraphs" ]
#      ; asm_cfi_supported = true
#      ; with_frame_pointers = false
#      ; ext_exe = ""
#      ; ext_obj = ".o"
#      ; ext_asm = ".s"
#      ; ext_lib = ".a"
#      ; ext_dll = ".so"
#      ; os_type = "Unix"
#      ; default_executable_name = "a.out"
#      ; systhread_supported = true
#      ; host = "aarch64-apple-darwin22.1.0"
#      ; target = "aarch64-apple-darwin22.1.0"
#      ; profiling = false
#      ; flambda = false
#      ; spacetime = false
#      ; safe_string = true
#      ; exec_magic_number = "Caml1999X031"
#      ; cmi_magic_number = "Caml1999I031"
#      ; cmo_magic_number = "Caml1999O031"
#      ; cma_magic_number = "Caml1999A031"
#      ; cmx_magic_number = "Caml1999Y031"
#      ; cmxa_magic_number = "Caml1999Z031"
#      ; ast_impl_magic_number = "Caml1999M031"
#      ; ast_intf_magic_number = "Caml1999N031"
#      ; cmxs_magic_number = "Caml1999D031"
#      ; cmt_magic_number = "Caml1999T031"
#      ; natdynlink_supported = true
#      ; supports_shared_libraries = true
#      ; windows_unicode = false
#      }
#  ; instrument_with = []
#  }
$ (cd _build/default && /opt/homebrew/bin/ocamldep.opt -modules -impl bin/main.ml) > _build/default/bin/.main.eobjs/dune__exe__Main.impl.d
$ (cd _build/default && /opt/homebrew/bin/ocamldep.opt -modules -impl bin/typeur.ml) > _build/default/bin/.main.eobjs/dune__exe__Typeur.impl.d
$ (cd _build/default && /opt/homebrew/bin/ocamlc.opt -w @1..3@5..28@30..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -bin-annot -I bin/.main.eobjs/byte -I lib/.Miniml.objs/byte -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/byte/dune__exe__Typeur.cmo -c -impl bin/typeur.ml)
> File "bin/typeur.ml", line 79, characters 2-116:
> 79 |   (**| Forall (set, t1) -> "Forall " ^(StringSet.fold (fun elem acc -> acc ^ elem) set "" )^ " "^(print_type t1)  *)
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 50 [unexpected-docstring]: unattached documentation comment (ignored)
> File "bin/typeur.ml", line 277, characters 62-214:
> 277 |     Var v -> let tv : ptype = cherche_type v e in [(ty, tv)]  (** La fonction renvoie une liste contenant une seule équation de type qui indique que  le type attendu ty est équivalent au type de la variable v. *)
>                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 50 [unexpected-docstring]: unattached documentation comment (ignored)
> File "bin/typeur.ml", lines 74-81, characters 2-41:
> 74 | ..match t with
> 75 |     Var x -> x
> 76 |   | Arr (t1, t2) -> "(" ^ (print_type t1) ^" -> "^ (print_type t2) ^")"
> 77 |   | Nat -> "Nat"
> 78 |   | Tliste l -> "[" ^ print_type l ^ "]"
> 79 |   (**| Forall (set, t1) -> "Forall " ^(StringSet.fold (fun elem acc -> acc ^ elem) set "" )^ " "^(print_type t1)  *)
> 80 |   |UnitT -> "unit"
> 81 |   |RefT e -> "(ref " ^(print_type e) ^")"
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Forall (_, _)
> File "bin/typeur.ml", lines 110-117, characters 2-17:
> 110 | ..match t with
> 111 |     Var v1 when v1 = v -> t0
> 112 |   | Var v2 -> Var v2
> 113 |   | Arr (t1, t2) -> Arr (substitue_type t1 v t0, substitue_type t2 v t0) 
> 114 |   | Nat -> Nat 
> 115 |   |Tliste l -> Tliste(substitue_type l v t0)
> 116 |   |RefT t1 -> RefT(substitue_type t1 v t0)
> 117 |   |UnitT -> UnitT
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Forall (_, _)
> File "bin/typeur.ml", lines 127-155, characters 2-90:
> 127 | ..match l with
> 128 |   | Var variable_to_replace ->
> 129 |     (match acc with
> 130 |     | [] ->
> 131 |         let nv = nouvelle_var () in
> ...
> 152 |   |Unit -> Unit
> 153 |   | ListP l ->match l with 
> 154 |              |Vide ->ListP(Vide)
> 155 |              |Cons (l1, ls)-> ListP(Cons((alpha_conv_bis l1 acc), alpha_conv_list ls acc))
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Pfix (_, _, _)|Assign (_, _))
> File "bin/typeur.ml", line 215, characters 15-16:
> 215 |               |_ -> raise Echec_reduction)
>                      ^
> Warning 11 [redundant-case]: this match case is unused.
> File "bin/typeur.ml", lines 210-215, characters 14-42:
> 210 | ..............(match t1 with 
> 211 |               |ListP(Vide)-> ListP(Vide)
> 212 |               |ListP(Cons(_,rest)) -> match rest with 
> 213 |                                     |Vide -> ListP(Vide)
> 214 |                                     |Cons(l1,ls) -> ListP(Cons ((reduction l1 acc), (map_list ls acc reduction)));
> 215 |               |_ -> raise Echec_reduction)
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Unit|Var _|App (_, _)|Abs (_, _)|N _|Add (_, _)|Sou (_, _)|Hd _|Tail _|
> Izte (_, _, _)|Iete (_, _, _)|Pfix (_, _, _)|Let (_, _, _)|Ref _|DeRef _|
> Assign (_, _))
> File "bin/typeur.ml", line 240, characters 29-30:
> 240 |                             |_ -> raise Echec_reduction)
>                                    ^
> Warning 11 [redundant-case]: this match case is unused.
> File "bin/typeur.ml", lines 276-318, characters 2-41:
> 276 | ..match te with 
> 277 |     Var v -> let tv : ptype = cherche_type v e in [(ty, tv)]  (** La fonction renvoie une liste contenant une seule équation de type qui indique que  le type attendu ty est équivalent au type de la variable v. *)
> 278 |   | App (t1, t2) -> let nv : string = nouvelle_var () in 
> 279 |       let eq1 : equa = genere_equa t1 (Arr (Var nv, ty)) e in  (* le type  attendue de de t1 est un Arr(Var nv), ty) *)
> 280 |       let eq2 : equa = genere_equa t2 (Var nv) e in
> ...
> 315 |                 let eq1: equa= (genere_equa t1 (RefT (Var nvh))  e) in 
> 316 |                   (ty, (Var nvh))::eq1
> 317 |   |Assign (t1, t2) -> let nv: string = nouvelle_var() in (let eq1: equa = (genere_equa t1 (RefT (Var nv)) e) and  eq2: equa = (genere_equa t2 (Var nv ) e ) in 
> 318 |                   (ty, UnitT)::(eq1@eq2))
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Unit|Pfix (_, _, _))
> File "bin/typeur.ml", line 325, characters 8-17:
> 325 | let rec rembobine (e : equa_zip) =
>               ^^^^^^^^^
> Warning 39 [unused-rec-flag]: unused rec flag.
> File "bin/typeur.ml", lines 345-370, characters 2-55:
> 345 | ..match e with 
> 346 |     (* on a passé toutes les équations : succes *)
> 347 |     (_, []) -> (try trouve_but (rembobine e) but with VarPasTrouve -> raise (Echec_unif "but pas trouvé"))
> 348 |     (* equation avec but : on passe *)
> 349 |   | (e1, (Var v1, t2)::e2) when v1 = but ->  unification ((Var v1, t2)::e1, e2) but
> ...
> 367 |   | (e1, (t3, Nat)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))   
> 368 |   | (e1,(Tliste t1, Tliste t2)::e2) -> unification(e1,(t1,t2)::e2) but (* Aboubakar Diawara *)
> 369 |   | (e1,(RefT t1,RefT t2)::e2) -> unification (e1,(t1,t2)::e2) but
> 370 |   | (e1,(UnitT ,UnitT )::e2) -> unification (e1,e2) but
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, (Tliste _, (UnitT|Forall (_, _)|RefT _))::_)
> File "bin/typeur.ml", line 96, characters 14-15:
> 96 |   | (v1, t1)::q when v1 = v -> t1
>                    ^
> Warning 27 [unused-var-strict]: unused variable q.
> File "bin/typeur.ml", line 178, characters 23-27:
> 178 |   | (variable, value)::tail when  s= variable -> value
>                              ^^^^
> Warning 27 [unused-var-strict]: unused variable tail.
> File "bin/typeur.ml", line 179, characters 5-13:
> 179 |   | (variable, value)::tail  ->  find_in_memo s tail
>            ^^^^^^^^
> Warning 27 [unused-var-strict]: unused variable variable.
> File "bin/typeur.ml", line 179, characters 15-20:
> 179 |   | (variable, value)::tail  ->  find_in_memo s tail
>                      ^^^^^
> Warning 27 [unused-var-strict]: unused variable value.
> File "bin/typeur.ml", line 244, characters 29-30:
> 244 |                         |Ref p -> e2
>                                    ^
> Warning 27 [unused-var-strict]: unused variable p.
> File "bin/typeur.ml", line 308, characters 8-12:
> 308 |     let nvh2 : string = nouvelle_var() in
>               ^^^^
> Warning 26 [unused-var]: unused variable nvh2.
> File "bin/typeur.ml", line 359, characters 5-7:
> 359 |   | (e1, (Arr (_,_), t3)::e2) -> raise (Echec_unif ("type fleche non-unifiable avec "^(print_type t3)))     
>            ^^
> Warning 27 [unused-var-strict]: unused variable e1.
> File "bin/typeur.ml", line 359, characters 26-28:
> 359 |   | (e1, (Arr (_,_), t3)::e2) -> raise (Echec_unif ("type fleche non-unifiable avec "^(print_type t3)))     
>                                 ^^
> Warning 27 [unused-var-strict]: unused variable e2.
> File "bin/typeur.ml", line 361, characters 5-7:
> 361 |   | (e1, (t3, Arr (_,_))::e2) -> raise (Echec_unif ("type fleche non-unifiable avec "^(print_type t3)))     
>            ^^
> Warning 27 [unused-var-strict]: unused variable e1.
> File "bin/typeur.ml", line 361, characters 26-28:
> 361 |   | (e1, (t3, Arr (_,_))::e2) -> raise (Echec_unif ("type fleche non-unifiable avec "^(print_type t3)))     
>                                 ^^
> Warning 27 [unused-var-strict]: unused variable e2.
> File "bin/typeur.ml", line 365, characters 5-7:
> 365 |   | (e1, (Nat, t3)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))     
>            ^^
> Warning 27 [unused-var-strict]: unused variable e1.
> File "bin/typeur.ml", line 365, characters 20-22:
> 365 |   | (e1, (Nat, t3)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))     
>                           ^^
> Warning 27 [unused-var-strict]: unused variable e2.
> File "bin/typeur.ml", line 367, characters 5-7:
> 367 |   | (e1, (t3, Nat)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))   
>            ^^
> Warning 27 [unused-var-strict]: unused variable e1.
> File "bin/typeur.ml", line 367, characters 20-22:
> 367 |   | (e1, (t3, Nat)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))   
>                           ^^
> Warning 27 [unused-var-strict]: unused variable e2.
$ (cd _build/default && /opt/homebrew/bin/ocamlopt.opt -w @1..3@5..28@30..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I lib/.Miniml.objs/byte -I lib/.Miniml.objs/native -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Main.cmx -c -impl bin/main.ml)
> File "bin/main.ml", lines 67-75, characters 2-33:
> 67 | ..(**
> 68 |   print_endline "======================";
> 69 |   print_endline inf_ex_nat3;
> 70 |   print_endline "======================";
> 71 |   print_endline ex_Tail_string;
> 72 |   print_endline "======================";
> 73 |   print_endline ex_hd_string;
> 74 |   print_endline "======================";
> 75 |   print_endline ex_zero_string;*)
> Warning 50 [unexpected-docstring]: unattached documentation comment (ignored)
> File "bin/main.ml", line 29, characters 4-12:
> 29 | let ex_omega : Typeur.pterm = Typeur.App (Typeur.Abs ("x", Typeur.App (Typeur.Var "x", Typeur.Var "x")), Typeur.Abs ("x", Typeur.App (Typeur.Var "x",Typeur. Var "x")))
>          ^^^^^^^^
> Warning 32 [unused-value-declaration]: unused value ex_omega.
> File "bin/main.ml", line 32, characters 4-15:
> 32 | let exemple_let: Typeur.pterm = Typeur.Let("x", (Typeur.Var "x" ), (Typeur.Var "x"))
>          ^^^^^^^^^^^
> Warning 32 [unused-value-declaration]: unused value exemple_let.
> File "bin/main.ml", line 34, characters 4-11:
> 34 | let exemple = Typeur.alpha_conv_bis ex_s []
>          ^^^^^^^
> Warning 32 [unused-value-declaration]: unused value exemple.
> File "bin/main.ml", line 46, characters 4-11:
> 46 | let ex_ifz2 : Typeur.pterm = Typeur.Izte((N 0), ex_sous, ex_sous)
>          ^^^^^^^
> Warning 32 [unused-value-declaration]: unused value ex_ifz2.
> File "bin/main.ml", line 53, characters 4-15:
> 53 | let ex_liste_ab : Typeur.pterm = Typeur.ListP(Typeur.Vide)
>          ^^^^^^^^^^^
> Warning 32 [unused-value-declaration]: unused value ex_liste_ab.
> File "bin/main.ml", line 61, characters 4-14:
> 61 | let ex_deref_3 : Typeur.pterm =Typeur.DeRef(ex_ref_3)
>          ^^^^^^^^^^
> Warning 32 [unused-value-declaration]: unused value ex_deref_3.
> File "bin/main.ml", line 62, characters 4-11:
> 62 | let ex_ref2 : Typeur.pterm = Typeur.Let("x",Typeur.DeRef((Var "x")), Typeur.DeRef((Var "y")))
>          ^^^^^^^
> Warning 32 [unused-value-declaration]: unused value ex_ref2.
$ (cd _build/default && /opt/homebrew/bin/ocamlopt.opt -w @1..3@5..28@30..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I lib/.Miniml.objs/byte -I lib/.Miniml.objs/native -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Typeur.cmx -c -impl bin/typeur.ml)
> File "bin/typeur.ml", line 79, characters 2-116:
> 79 |   (**| Forall (set, t1) -> "Forall " ^(StringSet.fold (fun elem acc -> acc ^ elem) set "" )^ " "^(print_type t1)  *)
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 50 [unexpected-docstring]: unattached documentation comment (ignored)
> File "bin/typeur.ml", line 277, characters 62-214:
> 277 |     Var v -> let tv : ptype = cherche_type v e in [(ty, tv)]  (** La fonction renvoie une liste contenant une seule équation de type qui indique que  le type attendu ty est équivalent au type de la variable v. *)
>                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 50 [unexpected-docstring]: unattached documentation comment (ignored)
> File "bin/typeur.ml", lines 74-81, characters 2-41:
> 74 | ..match t with
> 75 |     Var x -> x
> 76 |   | Arr (t1, t2) -> "(" ^ (print_type t1) ^" -> "^ (print_type t2) ^")"
> 77 |   | Nat -> "Nat"
> 78 |   | Tliste l -> "[" ^ print_type l ^ "]"
> 79 |   (**| Forall (set, t1) -> "Forall " ^(StringSet.fold (fun elem acc -> acc ^ elem) set "" )^ " "^(print_type t1)  *)
> 80 |   |UnitT -> "unit"
> 81 |   |RefT e -> "(ref " ^(print_type e) ^")"
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Forall (_, _)
> File "bin/typeur.ml", lines 110-117, characters 2-17:
> 110 | ..match t with
> 111 |     Var v1 when v1 = v -> t0
> 112 |   | Var v2 -> Var v2
> 113 |   | Arr (t1, t2) -> Arr (substitue_type t1 v t0, substitue_type t2 v t0) 
> 114 |   | Nat -> Nat 
> 115 |   |Tliste l -> Tliste(substitue_type l v t0)
> 116 |   |RefT t1 -> RefT(substitue_type t1 v t0)
> 117 |   |UnitT -> UnitT
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Forall (_, _)
> File "bin/typeur.ml", lines 127-155, characters 2-90:
> 127 | ..match l with
> 128 |   | Var variable_to_replace ->
> 129 |     (match acc with
> 130 |     | [] ->
> 131 |         let nv = nouvelle_var () in
> ...
> 152 |   |Unit -> Unit
> 153 |   | ListP l ->match l with 
> 154 |              |Vide ->ListP(Vide)
> 155 |              |Cons (l1, ls)-> ListP(Cons((alpha_conv_bis l1 acc), alpha_conv_list ls acc))
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Pfix (_, _, _)|Assign (_, _))
> File "bin/typeur.ml", line 215, characters 15-16:
> 215 |               |_ -> raise Echec_reduction)
>                      ^
> Warning 11 [redundant-case]: this match case is unused.
> File "bin/typeur.ml", lines 210-215, characters 14-42:
> 210 | ..............(match t1 with 
> 211 |               |ListP(Vide)-> ListP(Vide)
> 212 |               |ListP(Cons(_,rest)) -> match rest with 
> 213 |                                     |Vide -> ListP(Vide)
> 214 |                                     |Cons(l1,ls) -> ListP(Cons ((reduction l1 acc), (map_list ls acc reduction)));
> 215 |               |_ -> raise Echec_reduction)
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Unit|Var _|App (_, _)|Abs (_, _)|N _|Add (_, _)|Sou (_, _)|Hd _|Tail _|
> Izte (_, _, _)|Iete (_, _, _)|Pfix (_, _, _)|Let (_, _, _)|Ref _|DeRef _|
> Assign (_, _))
> File "bin/typeur.ml", line 240, characters 29-30:
> 240 |                             |_ -> raise Echec_reduction)
>                                    ^
> Warning 11 [redundant-case]: this match case is unused.
> File "bin/typeur.ml", lines 276-318, characters 2-41:
> 276 | ..match te with 
> 277 |     Var v -> let tv : ptype = cherche_type v e in [(ty, tv)]  (** La fonction renvoie une liste contenant une seule équation de type qui indique que  le type attendu ty est équivalent au type de la variable v. *)
> 278 |   | App (t1, t2) -> let nv : string = nouvelle_var () in 
> 279 |       let eq1 : equa = genere_equa t1 (Arr (Var nv, ty)) e in  (* le type  attendue de de t1 est un Arr(Var nv), ty) *)
> 280 |       let eq2 : equa = genere_equa t2 (Var nv) e in
> ...
> 315 |                 let eq1: equa= (genere_equa t1 (RefT (Var nvh))  e) in 
> 316 |                   (ty, (Var nvh))::eq1
> 317 |   |Assign (t1, t2) -> let nv: string = nouvelle_var() in (let eq1: equa = (genere_equa t1 (RefT (Var nv)) e) and  eq2: equa = (genere_equa t2 (Var nv ) e ) in 
> 318 |                   (ty, UnitT)::(eq1@eq2))
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Unit|Pfix (_, _, _))
> File "bin/typeur.ml", line 325, characters 8-17:
> 325 | let rec rembobine (e : equa_zip) =
>               ^^^^^^^^^
> Warning 39 [unused-rec-flag]: unused rec flag.
> File "bin/typeur.ml", lines 345-370, characters 2-55:
> 345 | ..match e with 
> 346 |     (* on a passé toutes les équations : succes *)
> 347 |     (_, []) -> (try trouve_but (rembobine e) but with VarPasTrouve -> raise (Echec_unif "but pas trouvé"))
> 348 |     (* equation avec but : on passe *)
> 349 |   | (e1, (Var v1, t2)::e2) when v1 = but ->  unification ((Var v1, t2)::e1, e2) but
> ...
> 367 |   | (e1, (t3, Nat)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))   
> 368 |   | (e1,(Tliste t1, Tliste t2)::e2) -> unification(e1,(t1,t2)::e2) but (* Aboubakar Diawara *)
> 369 |   | (e1,(RefT t1,RefT t2)::e2) -> unification (e1,(t1,t2)::e2) but
> 370 |   | (e1,(UnitT ,UnitT )::e2) -> unification (e1,e2) but
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, (Tliste _, (UnitT|Forall (_, _)|RefT _))::_)
> File "bin/typeur.ml", line 96, characters 14-15:
> 96 |   | (v1, t1)::q when v1 = v -> t1
>                    ^
> Warning 27 [unused-var-strict]: unused variable q.
> File "bin/typeur.ml", line 178, characters 23-27:
> 178 |   | (variable, value)::tail when  s= variable -> value
>                              ^^^^
> Warning 27 [unused-var-strict]: unused variable tail.
> File "bin/typeur.ml", line 179, characters 5-13:
> 179 |   | (variable, value)::tail  ->  find_in_memo s tail
>            ^^^^^^^^
> Warning 27 [unused-var-strict]: unused variable variable.
> File "bin/typeur.ml", line 179, characters 15-20:
> 179 |   | (variable, value)::tail  ->  find_in_memo s tail
>                      ^^^^^
> Warning 27 [unused-var-strict]: unused variable value.
> File "bin/typeur.ml", line 244, characters 29-30:
> 244 |                         |Ref p -> e2
>                                    ^
> Warning 27 [unused-var-strict]: unused variable p.
> File "bin/typeur.ml", line 308, characters 8-12:
> 308 |     let nvh2 : string = nouvelle_var() in
>               ^^^^
> Warning 26 [unused-var]: unused variable nvh2.
> File "bin/typeur.ml", line 359, characters 5-7:
> 359 |   | (e1, (Arr (_,_), t3)::e2) -> raise (Echec_unif ("type fleche non-unifiable avec "^(print_type t3)))     
>            ^^
> Warning 27 [unused-var-strict]: unused variable e1.
> File "bin/typeur.ml", line 359, characters 26-28:
> 359 |   | (e1, (Arr (_,_), t3)::e2) -> raise (Echec_unif ("type fleche non-unifiable avec "^(print_type t3)))     
>                                 ^^
> Warning 27 [unused-var-strict]: unused variable e2.
> File "bin/typeur.ml", line 361, characters 5-7:
> 361 |   | (e1, (t3, Arr (_,_))::e2) -> raise (Echec_unif ("type fleche non-unifiable avec "^(print_type t3)))     
>            ^^
> Warning 27 [unused-var-strict]: unused variable e1.
> File "bin/typeur.ml", line 361, characters 26-28:
> 361 |   | (e1, (t3, Arr (_,_))::e2) -> raise (Echec_unif ("type fleche non-unifiable avec "^(print_type t3)))     
>                                 ^^
> Warning 27 [unused-var-strict]: unused variable e2.
> File "bin/typeur.ml", line 365, characters 5-7:
> 365 |   | (e1, (Nat, t3)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))     
>            ^^
> Warning 27 [unused-var-strict]: unused variable e1.
> File "bin/typeur.ml", line 365, characters 20-22:
> 365 |   | (e1, (Nat, t3)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))     
>                           ^^
> Warning 27 [unused-var-strict]: unused variable e2.
> File "bin/typeur.ml", line 367, characters 5-7:
> 367 |   | (e1, (t3, Nat)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))   
>            ^^
> Warning 27 [unused-var-strict]: unused variable e1.
> File "bin/typeur.ml", line 367, characters 20-22:
> 367 |   | (e1, (t3, Nat)::e2) -> raise (Echec_unif ("type entier non-unifiable avec "^(print_type t3)))   
>                           ^^
> Warning 27 [unused-var-strict]: unused variable e2.
$ (cd _build/default && /opt/homebrew/bin/ocamlopt.opt -w @1..3@5..28@30..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -o bin/main.exe lib/Miniml.cmxa bin/.main.eobjs/native/dune__exe.cmx bin/.main.eobjs/native/dune__exe__Typeur.cmx bin/.main.eobjs/native/dune__exe__Main.cmx)
